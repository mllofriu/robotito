///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.50.0.50277/W32 for Atmel AVR   16/Aug/2011  11:18:10 /
// Copyright (C) 1996-2010 IAR Systems AB.                                    /
//                                                                            /
//    Source file  =  E:\F Drive\Project\Bootloader project\Code\Common for   /
//                    All Devices\TWI_Slave\TWI_Slave.c                       /
//    Command line =  "E:\F Drive\Project\Bootloader project\Code\Common for  /
//                    All Devices\TWI_Slave\TWI_Slave.c" --cpu=tiny88 -ms -o  /
//                    "E:\F Drive\Project\Bootloader project\Code\Common for  /
//                    All Devices\TWI_Slave\Release\Obj\" -D __ATTINY88__     /
//                    --preprocess "E:\F Drive\Project\Bootloader             /
//                    project\Code\Common for All                             /
//                    Devices\TWI_Slave\Release\List\" -lCN "E:\F             /
//                    Drive\Project\Bootloader project\Code\Common for All    /
//                    Devices\TWI_Slave\Release\List\" -lB "E:\F              /
//                    Drive\Project\Bootloader project\Code\Common for All    /
//                    Devices\TWI_Slave\Release\List\"                        /
//                    --initializers_in_flash -z9 -DENABLE_BIT_DEFINITIONS    /
//                    -e -I "C:\Program Files\IAR Systems\Embedded Workbench  /
//                    5.4\avr\INC\" -I "C:\Program Files\IAR                  /
//                    Systems\Embedded Workbench 5.4\avr\INC\CLIB\"           /
//                    --eeprom_size 64                                        /
//    List file    =  E:\F Drive\Project\Bootloader project\Code\Common for   /
//                    All Devices\TWI_Slave\Release\List\TWI_Slave.s90        /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME TWI_Slave

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?EPILOGUE_B3_L09
        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?PROLOGUE3_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC AbortTWI
        PUBLIC CleanupAndRunApplication
        PUBLIC Disable_WatchDogTimer
        PUBLIC Erase_One_Page
        PUBLIC GetStatusCode
        PUBLIC Host_Boot_Delay
        PUBLIC InitTWI
        PUBLIC Init_WatchDogTimer
        PUBLIC IsBootPinLow
        PUBLIC ProcessPageErase
        PUBLIC ProcessPageUpdate
        PUBLIC ProcessSlaveReceive
        PUBLIC ProcessSlaveTransmit
        PUBLIC ReadAndProcessPacket
        PUBLIC Read_EEPROM_byte
        PUBLIC SlaveReceiveByteAndACK
        PUBLIC SlaveReceiveByteAndNACK
        PUBLIC Start_Timer
        PUBLIC UpdatePage
        PUBWEAK _A_DDRB
        PUBWEAK _A_DDRC
        PUBWEAK _A_EEAR
        PUBWEAK _A_EECR
        PUBWEAK _A_EEDR
        PUBWEAK _A_MCUSR
        PUBWEAK _A_OCR1A
        PUBWEAK _A_PINB
        PUBWEAK _A_PORTB
        PUBWEAK _A_PORTC
        PUBWEAK _A_SPMCSR
        PUBWEAK _A_TCCR1B
        PUBWEAK _A_TCNT1
        PUBWEAK _A_TIFR1
        PUBWEAK _A_TWAR
        PUBWEAK _A_TWCR
        PUBWEAK _A_TWDR
        PUBWEAK _A_TWSR
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC gtimeout
        PUBLIC main
        PUBLIC pageBuffer
        PUBLIC state
        PUBLIC statusCode
        PUBLIC time_lapse_sec

// E:\F Drive\Project\Bootloader project\Code\Common for All Devices\TWI_Slave\TWI_Slave.c
//    1 #include <ioavr.h>

        ASEGN ABSOLUTE:DATA:NOROOT,0bcH
// <__C9> volatile __io _A_TWCR
_A_TWCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0bbH
// <__C11> volatile __io _A_TWDR
_A_TWDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0baH
// <__C14> volatile __io _A_TWAR
_A_TWAR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,0b9H
// <__C17> volatile __io _A_TWSR
_A_TWSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,088H
// <__C27> volatile __io _A_OCR1A
_A_OCR1A:
        DS8 2

        ASEGN ABSOLUTE:DATA:NOROOT,084H
// <__C35> volatile __io _A_TCNT1
_A_TCNT1:
        DS8 2

        ASEGN ABSOLUTE:DATA:NOROOT,081H
// <__C41> volatile __io _A_TCCR1B
_A_TCCR1B:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,057H
// <__C110> volatile __io _A_SPMCSR
_A_SPMCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,054H
// <__C116> volatile __io _A_MCUSR
_A_MCUSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,041H
// <__C150> volatile __io _A_EEAR
_A_EEAR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,040H
// <__C152> volatile __io _A_EEDR
_A_EEDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,03fH
// <__C155> volatile __io _A_EECR
_A_EECR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,036H
// <__C169> volatile __io _A_TIFR1
_A_TIFR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,028H
// <__C196> volatile __io _A_PORTC
_A_PORTC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,027H
// <__C199> volatile __io _A_DDRC
_A_DDRC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,025H
// <__C205> volatile __io _A_PORTB
_A_PORTB:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,024H
// <__C208> volatile __io _A_DDRB
_A_DDRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,023H
// <__C211> volatile __io _A_PINB
_A_PINB:
        DS8 1
//    2 #include "stdint.h"
//    3 #include <inavr.h>
//    4 #include "Common_Define.h"

        RSEG NEAR_N:DATA:NOROOT(0)
// uint8_t pageBuffer[64]
pageBuffer:
        DS8 64
//    5 
//    6 #ifdef __USI__
//    7     #include "USI_TWI_Slave.c"
//    8     #include "USI_TWI_Slave.h"
//    9 #endif
//   10 
//   11 
//   12 //configuring LAST_INTVECT_ADDRESS as per device selected
//   13 /*****************************************************************************/
//   14 #ifdef __TWI__
//   15   #if  defined(__ATMEGA48__) | \ 
//   16        defined(__ATMEGA48A__) | defined(__ATMEGA48PA__)
//   17        #define LAST_INTVECT_ADDRESS 		SPM_READY_vect  // The start of the application code
//   18   #endif
//   19 
//   20   /*****************************************************************************/
//   21   #if defined(__ATTINY48__) | defined(__ATTINY88__)
//   22      #define LAST_INTVECT_ADDRESS 		TWI_vect// The start of the application code
//   23   #endif
//   24   /*****************************************************************************/
//   25 #endif
//   26 
//   27 
//   28 
//   29 #ifdef __USI__
//   30  /*****************************************************************************/
//   31     #if defined(__ATTINY167__) 
//   32        #define LAST_INTVECT_ADDRESS 	USI_START_vect// The start of the application code
//   33     #endif
//   34 
//   35     #if defined(__ATTINY85__) 
//   36        #define LAST_INTVECT_ADDRESS 	USI_OVF_vect// The start of the application code
//   37     #endif
//   38  /*****************************************************************************/
//   39 
//   40  /*****************************************************************************/
//   41  /*****************************************************************************/
//   42  /*****************************************************************************/
//   43  /*****************************************************************************/
//   44  /*****************************************************************************/
//   45  /*****************************************************************************/
//   46 #endif
//   47 
//   48 
//   49 
//   50 /*****************************************************************************/
//   51 /*****************************************************************************/
//   52 #ifdef __TWI__
//   53 #define TWI_SLAW_RECEIVED         	0x60	// Status slave address and write command received
//   54 #define TWI_SLAR_RECEIVED         	0xa8	// Status slave address and read command received
//   55 #define TWI_SLAVETX_NACK_RECEIVED 	0xc0	// Status slave transmit and no acknowledgement or last byte
//   56 #define TWI_SLAVERX_ACK_RETURNED  	0x80	// Status slave receive and acknowledgement returned
//   57 #define TWI_SLAVERX_NACK_RETURNED 	0x88	// Status slave receive and no acknowledgement or last byte
//   58 
//   59 #endif
//   60 
//   61 //

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   62 uint8_t state = 0;
state:
        DS8 1
//   63 // __no_init uint8_t pageBuffer[PAGE_SIZE];
//   64 uint16_t time_lapse_sec = 0; 
//   65 uint8_t volatile gtimeout;
gtimeout:
        DS8 1

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
time_lapse_sec:
        DS8 2

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   66 uint8_t statusCode = 0;
statusCode:
        DS8 1
//   67 
//   68 /***********************************************************************/
//   69 
//   70 /***********************************************************************/
//   71 #ifdef __TWI__

        RSEG CODE:CODE:NOROOT(1)
//   72 void InitTWI (void)
InitTWI:
//   73 {
//   74   
//   75   DDRC &= ~((1 << PORTC5) | (1 << PORTC4)); // Set SCL and SDA as input
        IN      R16, 0x07
        ANDI    R16, 0xCF
        OUT     0x07, R16
//   76   PORTC &= ~((1 << PORTC5) | (1 << PORTC4)); // Set SCL and SDA low
        IN      R16, 0x08
        ANDI    R16, 0xCF
        OUT     0x08, R16
//   77   // Note: PORTC4 and PORT5 commonly used for tiny48. tiny88, mega48 TWI based devices
//   78   
//   79   TWAR = SLAVE_ADDRESS;
        LDI     R16, 176
        STS     _A_TWAR, R16
//   80   TWCR = (1 << TWEN);		
        LDI     R16, 4
        RJMP    ??Subroutine12_0
        REQUIRE _A_TWCR
        REQUIRE _A_TWAR
        REQUIRE _A_PORTC
        REQUIRE _A_DDRC
//   81   // Enable, but don't enable ACK until we are ready to receive packets.
//   82 
//   83 }
//   84 #endif
//   85 /***********************************************************************/
//   86 
//   87 
//   88 
//   89 /***********************************************************************/
//   90 //! Return non-zero if "Enter Bootloader" pin is held low externally.

        RSEG CODE:CODE:NOROOT(1)
//   91 uint8_t IsBootPinLow (void)
IsBootPinLow:
//   92 {
//   93   // Make sure "Enter Bootloader" pin is input with internal pull-up.
//   94 #if defined(__ATTINY24__)   | defined(__ATTINY24A__) | \ 
//   95     defined(__ATTINY44__)   | defined(__ATTINY44A__) | \ 
//   96     defined(__ATTINY84__)   | defined(__ATTINY84A__) | \ 
//   97     defined(__ATTINY2313__) | defined(__ATTINY2313A__) | \ 
//   98     defined(__ATTINY4313__) | defined(__ATTINY4313A__) | \ 
//   99     defined(__ATTINY43U__)  | \ 
//  100     defined(__ATTINY87__) | defined(__ATTINY167__) | \ 
//  101     defined(__ATTINY48__)   | defined(__ATTINY88__) | \ 
//  102     defined(__ATMEGA48__) | \ 
//  103     defined(__ATMEGA48A__) | defined(__ATMEGA48PA__)
//  104     
//  105      DDRB &= ~(1 << PORTB0);  //making port pin as input
        CBI     0x04, 0x00
//  106     PORTB |= (1 << PORTB0);   
        SBI     0x05, 0x00
//  107     // Let it settle.
//  108   __delay_cycles (BOOT_SETTLE_DELAY);
        LDI     R16, 33
        DEC     R16
        BRNE    $-2
        NOP
//  109   // Return non-zero if pin is low.
//  110   return ((PINB & (1 << PORTB0)) == 0);
        LDI     R16, 0
        SBIC    0x03, 0x00
        LDI     R16, 1
??IsBootPinLow_0:
        LDI     R17, 1
        EOR     R16, R17
        RET
        REQUIRE _A_PORTB
        REQUIRE _A_DDRB
        REQUIRE _A_PINB
//  111 #endif
//  112   
//  113 #if defined(__ATTINY261__)  | defined(__ATTINY261A__) | \ 
//  114     defined(__ATTINY461__)  | defined(__ATTINY461A__) | \ 
//  115     defined(__ATTINY861__)  | defined(__ATTINY861A__) | \ 
//  116     defined(__ATTINY25__)   | defined(__ATTINY25V__) | \ 
//  117     defined(__ATTINY45__)   | defined(__ATTINY45V__) | \ 
//  118     defined(__ATTINY85__)   | defined(__ATTINY85V__)    
//  119     
//  120     DDRB &= ~(1 << PORTB4);   //making port pin as input
//  121     PORTB |= (1 << PORTB4); 
//  122     // Let it settle.
//  123   __delay_cycles (BOOT_SETTLE_DELAY);
//  124   // Return non-zero if pin is low.
//  125   return ((PINB & (1 << PORTB4)) == 0);
//  126 #endif
//  127 }
//  128 /***********************************************************************/
//  129 
//  130 
//  131 
//  132 /***********************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  133 uint8_t GetStatusCode (void)
GetStatusCode:
//  134 {
//  135   // Check if SPM operation is complete  
//  136   if ((SPMCSR & (1 << SELFPROGEN)) != 0) 
        IN      R16, 0x37
        SBRS    R16, 0
        RJMP    ??GetStatusCode_0
//  137     statusCode |= STATUSMASK_SPMBUSY;
        LDI     R30, LOW(statusCode)
        LDI     R31, (statusCode) >> 8
        LD      R16, Z
        ORI     R16, 0x01
        ST      Z, R16
//  138  
//  139   return statusCode;
??GetStatusCode_0:
        LDS     R16, statusCode
        RET
        REQUIRE _A_SPMCSR
//  140 }
//  141 /***********************************************************************/
//  142 
//  143 
//  144 /***********************************************************************/
//  145 #ifdef __TWI__

        RSEG CODE:CODE:NOROOT(1)
//  146 void AbortTWI (void)
AbortTWI:
//  147 {
//  148   // Recover from error condition by releasing bus lines.
//  149   TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
        REQUIRE ?Subroutine0
        REQUIRE _A_TWCR
        ;               // Fall through to label ?Subroutine0

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
        LDI     R16, 148
        REQUIRE ??Subroutine12_0
        ;               // Fall through to label ??Subroutine12_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine12_0:
        STS     _A_TWCR, R16
        RET
//  150 }
//  151 #endif
//  152 /***********************************************************************/
//  153 
//  154 
//  155 /***********************************************************************/
//  156 #ifdef __TWI__

        RSEG CODE:CODE:NOROOT(1)
//  157 void ProcessSlaveTransmit (uint8_t data)
ProcessSlaveTransmit:
//  158 {
//  159   // Prepare data for transmission.
//  160   TWDR = data;
        STS     _A_TWDR, R16
//  161   TWCR = (1 << TWINT) | (1 << TWEN);	// Send byte, NACK expected from master.
        LDI     R16, 132
        RCALL   ??Subroutine12_0
//  162   // Wait for activity.
//  163   do{} while ((TWCR & (1 << TWINT)) == 0);
??CrossCallReturnLabel_11:
        LDS     R16, _A_TWCR
        SBRS    R16, 7
        RJMP    ??CrossCallReturnLabel_11
//  164   __watchdog_reset ();
        WDR
//  165   // Check TWI status code for SLAVETX_NACK.
//  166   switch (TWSR)
        LDS     R16, _A_TWSR
        CPI     R16, 192
        BRNE    ??ProcessSlaveTransmit_0
//  167   {
//  168     case TWI_SLAVETX_NACK_RECEIVED:
//  169       // End communication.
//  170       TWCR = (1 << TWINT) | (1 << TWEN);
        LDI     R16, 132
        RJMP    ??ProcessSlaveTransmit_1
//  171       break;
//  172 
//  173     default:
//  174       AbortTWI ();
??ProcessSlaveTransmit_0:
        LDI     R16, 148
//  175   }
??ProcessSlaveTransmit_1:
        RJMP    ??Subroutine12_0
        REQUIRE _A_TWCR
        REQUIRE _A_TWDR
        REQUIRE _A_TWSR
//  176 }
//  177 #endif
//  178 /***********************************************************************/
//  179 
//  180 
//  181 /***********************************************************************/
//  182 #ifdef __TWI__

        RSEG CODE:CODE:NOROOT(1)
//  183 uint8_t SlaveReceiveByteAndACK (uint8_t * data)
SlaveReceiveByteAndACK:
//  184 {
//  185    // Receive byte and return ACK.
//  186   TWCR = (1 << TWINT) | (1 << TWEA) | (1 << TWEN);
        LDI     R18, 196
        STS     _A_TWCR, R18
//  187   // Wait for activity.
//  188   do{} while ((TWCR & (1 << TWINT)) == 0);
??SlaveReceiveByteAndACK_0:
        LDS     R18, _A_TWCR
        SBRS    R18, 7
        RJMP    ??SlaveReceiveByteAndACK_0
//  189   __watchdog_reset ();
        WDR
//  190   // Check TWI status code for SLAVERX_ACK.
//  191   switch (TWSR)
        LDS     R18, _A_TWSR
        CPI     R18, 128
        BRNE    ??SlaveReceiveByteAndACK_1
//  192   {
//  193     case TWI_SLAVERX_ACK_RETURNED:
//  194       // Get byte and return non-zero for success.
//  195       *data = TWDR;	  
        RCALL   ?Subroutine1
//  196       return 1;
??CrossCallReturnLabel_0:
        RJMP    ?Subroutine7
//  197 
//  198     default:	
//  199       AbortTWI ();
??SlaveReceiveByteAndACK_1:
        RJMP    ?Subroutine6
        REQUIRE _A_TWCR
        REQUIRE _A_TWDR
        REQUIRE _A_TWSR
//  200       return 0;
//  201   }
//  202 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine7:
        LDI     R16, 1
        RET

        RSEG CODE:CODE:NOROOT(1)
?Subroutine6:
        RCALL   ?Subroutine0
??CrossCallReturnLabel_17:
        LDI     R16, 0
        RET
//  203 #endif
//  204 /***********************************************************************/
//  205 
//  206 
//  207 /***********************************************************************/
//  208 #ifdef __TWI__

        RSEG CODE:CODE:NOROOT(1)
//  209 uint8_t SlaveReceiveByteAndNACK (uint8_t * data)
SlaveReceiveByteAndNACK:
//  210 {
//  211   // Receive byte and return NACK.
//  212   TWCR = (1 << TWINT) | (1 << TWEN);
        LDI     R18, 132
        STS     _A_TWCR, R18
//  213   // Wait for activity.
//  214   do{} while ((TWCR & (1 << TWINT)) == 0);
??SlaveReceiveByteAndNACK_0:
        LDS     R18, _A_TWCR
        SBRS    R18, 7
        RJMP    ??SlaveReceiveByteAndNACK_0
//  215   __watchdog_reset ();
        WDR
//  216   
//  217   // Check TWI status code for SLAVERX_ACK.
//  218   switch (TWSR)
        LDS     R18, _A_TWSR
        CPI     R18, 136
        BRNE    ??SlaveReceiveByteAndNACK_1
//  219   {
//  220     case TWI_SLAVERX_NACK_RETURNED:
//  221       // Get byte, end communication and return non-zero for success.
//  222       *data = TWDR;
        RCALL   ?Subroutine1
//  223       TWCR = (1 << TWINT) | (1 << TWEN);
??CrossCallReturnLabel_1:
        LDI     R16, 132
        RCALL   ??Subroutine12_0
//  224       return 1;
??CrossCallReturnLabel_12:
        RJMP    ?Subroutine7
//  225 
//  226     default:
//  227 	// Reset the SLRBAN busy LED
//  228       AbortTWI ();
??SlaveReceiveByteAndNACK_1:
        RJMP    ?Subroutine6
        REQUIRE _A_TWCR
        REQUIRE _A_TWDR
        REQUIRE _A_TWSR
//  229       return 0;
//  230   }
//  231 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine1:
        LDS     R18, _A_TWDR
        MOVW    R31:R30, R17:R16
        ST      Z, R18
        RET
//  232 #endif
//  233 /***********************************************************************/
//  234 
//  235 
//  236 /***********************************************************************/
//  237 /*  Absolute Unconditional Page Erase  Check bounds elsewhere    */

        RSEG CODE:CODE:NOROOT(1)
//  238 void Erase_One_Page (uint16_t addr) 
Erase_One_Page:
//  239 {
//  240   // Erase page at the given address
//  241   _SPM_ERASE (addr);
        LDI     R18, 3
        MOVW    R31:R30, R17:R16
        OUT     0x37, R18
        SPM
//  242 
//  243   do{} while ((SPMCSR & (1 << SELFPROGEN)) != 0);
??Erase_One_Page_0:
        IN      R16, 0x37
        SBRC    R16, 0
        RJMP    ??Erase_One_Page_0
//  244   __DataToR0ByteToSPMCR_SPM (0, ((1 << 4) | (1 << SELFPROGEN)));
        RCALL   ?Subroutine2
//  245   do{} while ((SPMCSR & (1 << SELFPROGEN)) != 0);
??CrossCallReturnLabel_2:
        IN      R16, 0x37
        SBRC    R16, 0
        RJMP    ??CrossCallReturnLabel_2
//  246 
//  247   
//  248 }
        RET
        REQUIRE _A_SPMCSR
//  249 /***********************************************************************/
//  250 
//  251 
//  252 
//  253 /***********************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  254 void UpdatePage (uint16_t pageAddress)
UpdatePage:
//  255 {
        RCALL   ?PROLOGUE4_L09
        MOVW    R25:R24, R17:R16
//  256   // Mask out in-page address bits.
//  257   pageAddress &= ~(PAGE_SIZE - 1);
        ANDI    R24, 0xC0
//  258   // Protect RESET vector if this is page 0.
//  259   if (pageAddress == INTVECT_PAGE_ADDRESS)
        MOV     R16, R24
        OR      R16, R17
        BRNE    ??UpdatePage_0
        LDI     R30, 0
        LDI     R31, 0
        LPM     R0, Z
        STS     pageBuffer, R0
//  260   {
//  261     // Load existing RESET vector contents into buffer.
//  262     pageBuffer[0] =
//  263     __load_program_memory ((void __flash *) (INTVECT_PAGE_ADDRESS + 0));
//  264     pageBuffer[1] =
//  265     __load_program_memory ((void __flash *) (INTVECT_PAGE_ADDRESS + 1));
        LDI     R30, LOW(1)
        LPM     R0, Z
        STS     (pageBuffer + 1), R0
        RJMP    ??UpdatePage_1
//  266   }
//  267 
//  268   // Ignore any attempt to update boot section.
//  269   if (pageAddress < BOOT_PAGE_ADDRESS)
??UpdatePage_0:
        CPI     R17, 28
        BRCC    ??UpdatePage_2
//  270   {
//  271     Erase_One_Page (pageAddress);
??UpdatePage_1:
        MOV     R16, R24
        RCALL   Erase_One_Page
//  272 
//  273     // Load temporary page buffer.
//  274     uint8_t *bufferPtr = pageBuffer;
        LDI     R26, LOW(pageBuffer)
        LDI     R27, (pageBuffer) >> 8
//  275     uint16_t tempAddress = pageAddress;
        MOVW    R17:R16, R25:R24
//  276     for (uint8_t i = 0; i < PAGE_SIZE; i += 2)
        LDI     R18, 32
//  277     {
//  278       uint16_t tempWord = ((bufferPtr[1] << 8) | bufferPtr[0]);
//  279       _SPM_FILLTEMP (tempAddress, tempWord); // Fill the temporary buffer with the given data
??UpdatePage_3:
        LDI     R19, 1
        MOVW    R31:R30, R27:R26
        LDD     R1, Z+1
        LD      R0, X
        MOVW    R31:R30, R17:R16
        OUT     0x37, R19
        SPM
//  280       tempAddress += 2;
        SUBI    R16, 254
        SBCI    R17, 255
//  281       bufferPtr += 2;
        ADIW    R27:R26, 2
//  282     }
        DEC     R18
        BRNE    ??UpdatePage_3
//  283     // Write page from temporary buffer to the given location in flasm memory
//  284     _SPM_PAGEWRITE (pageAddress);
        LDI     R16, 5
        MOVW    R31:R30, R25:R24
        OUT     0x37, R16
        SPM
//  285 
//  286 //SPMEN//SELFPROGEN
//  287     
//  288     do{} while ((SPMCSR & (1 << SELFPROGEN)) != 0); // Wait for the SPM operation to complete 
??UpdatePage_4:
        IN      R16, 0x37
        SBRC    R16, 0
        RJMP    ??UpdatePage_4
//  289     __DataToR0ByteToSPMCR_SPM (0, ((1 << 4) | (1 << SELFPROGEN))); // Clear Temporary Buffer
        RCALL   ?Subroutine2
//  290     do{} while ((SPMCSR & (1 << SELFPROGEN)) != 0); // Wait for the SPM operation to complete
??CrossCallReturnLabel_3:
        IN      R16, 0x37
        SBRC    R16, 0
        RJMP    ??CrossCallReturnLabel_3
//  291 
//  292     
//  293     __watchdog_reset (); // Reset the watchdog timer
        WDR
//  294   }
//  295 }
??UpdatePage_2:
        REQUIRE ?Subroutine9
        REQUIRE _A_SPMCSR
        ;               // Fall through to label ?Subroutine9

        RSEG CODE:CODE:NOROOT(1)
?Subroutine9:
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09

        RSEG CODE:CODE:NOROOT(1)
?Subroutine2:
        LDI     R17, 17
        CLR     R0
        OUT     0x37, R17
        SPM
        RET
//  296 
//  297 
//  298 /***********************************************************************/
//  299 
//  300 /***********************************************************************/
//  301 

        RSEG CODE:CODE:NOROOT(1)
//  302 void ProcessPageUpdate (void)
ProcessPageUpdate:
//  303 {
        RCALL   ?PROLOGUE3_L09
        SBIW    R29:R28, 2
//  304   // Check the SPM is ready, abort if not.
//  305   if ((SPMCSR & (1 << SELFPROGEN)) != 0)
        IN      R16, 0x37
        SBRS    R16, 0
        RJMP    ??ProcessPageUpdate_0
//  306   {
//  307     #ifdef __TWI__
//  308       AbortTWI ();
        RCALL   ?Subroutine0
//  309     #endif
//  310       
//  311       #ifdef __USI__
//  312        USI_TWI_SLAVE_Abort ();
//  313     #endif 
//  314       
//  315   }
??CrossCallReturnLabel_14:
        RJMP    ??ProcessPageUpdate_1
//  316   else
//  317   {
//  318     #ifdef __TWI__
//  319     uint8_t error = 0;
//  320     uint8_t pageAddressLo;
//  321     uint8_t pageAddressHi;
//  322     uint8_t *bufferPtr = pageBuffer;
??ProcessPageUpdate_0:
        LDI     R24, LOW(pageBuffer)
        LDI     R25, (pageBuffer) >> 8
//  323     
//  324     
//  325     // Receive two-byte page address.
//  326     error = SlaveReceiveByteAndACK (&pageAddressLo) == 0;
        MOVW    R17:R16, R29:R28
        SUBI    R16, 255
        SBCI    R17, 255
        RCALL   ??Subroutine13_0
??CrossCallReturnLabel_20:
        BREQ    ??ProcessPageUpdate_1
//  327     if (!error)
//  328     {
//  329       error = SlaveReceiveByteAndACK (&pageAddressHi) == 0;
        RCALL   ?Subroutine4
//  330     }
??CrossCallReturnLabel_18:
        BREQ    ??ProcessPageUpdate_1
//  331     // Receive page data.
//  332      if (!error)
//  333     {
//  334       for (uint8_t i = 0; i < (PAGE_SIZE - 1); ++i)
        LDI     R26, 0
//  335       {
//  336 	if (SlaveReceiveByteAndACK (bufferPtr) != 0)
??ProcessPageUpdate_2:
        MOVW    R17:R16, R25:R24
        RCALL   ??Subroutine13_0
??CrossCallReturnLabel_21:
        BREQ    ??ProcessPageUpdate_1
//  337 	{
//  338           ++bufferPtr;
        ADIW    R25:R24, 1
//  339 	}
//  340 	else
//  341 	{
//  342 	  error = 1;
//  343 	  break;
//  344 	}
//  345       }
        INC     R26
        CPI     R26, 63
        BRCS    ??ProcessPageUpdate_2
//  346     }
//  347 
//  348     if (!error)
//  349     {
//  350       error = SlaveReceiveByteAndNACK (bufferPtr) == 0;
        MOVW    R17:R16, R25:R24
        RCALL   SlaveReceiveByteAndNACK
        TST     R16
        BREQ    ??ProcessPageUpdate_1
//  351     }
//  352    
//  353     
//  354     // Now program if everything went well.
//  355     if (!error)
//  356     {
//  357       UpdatePage ((pageAddressHi << 8) | pageAddressLo);
        LD      R17, Y
        LDD     R16, Y+1
        RCALL   UpdatePage
//  358     }
//  359      #endif
//  360   }
//  361 }
??ProcessPageUpdate_1:
        ADIW    R29:R28, 2
        REQUIRE ?Subroutine10
        REQUIRE _A_SPMCSR
        REQUIRE _A_TWCR
        ;               // Fall through to label ?Subroutine10

        RSEG CODE:CODE:NOROOT(1)
?Subroutine10:
        LDI     R30, 3
        RJMP    ?EPILOGUE_B3_L09
//  362 
//  363 
//  364 /***********************************************************************/
//  365 
//  366 /***********************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  367 void Disable_WatchDogTimer (void)
Disable_WatchDogTimer:
//  368 {
//  369 /*  
//  370      Timed sequence
//  371      Interrupts are already disabled else additional code may go in to avoid
//  372      the servicing of interrupt in between the timed sequence
//  373 */
//  374   asm (" push r24         \n"	
//  375        " push r0          \n" 
//  376        " eor r0, r0       \n"	/*  r0 = 0 */
//  377        " ldi r24, 0x18    \n"   /* WDE and WDCE bits set    */
//  378        " wdr              \n"   /* Reset the watchdog timer */
//  379        " sts 0x0060, r24  \n"	/* WDCE, WDE set in WDTCSR  */
//  380        " sts 0x0054, r0   \n"	/* WDRF in MCUSR = 0        */
//  381        " sts 0x0060, r0   \n"	/* WDE in WDTCSR = 0        */
//  382        " pop r0           \n" 
//  383        " pop r24            ");
        push r24         
        push r0          
        eor r0, r0       
        ldi r24, 0x18    
        wdr              
        sts 0x0060, r24  
        sts 0x0054, r0   
        sts 0x0060, r0   
        pop r0           
        pop r24            
//  384 }
        RET
//  385 
//  386 /***********************************************************************/
//  387 
//  388 /***********************************************************************/
//  389 

        RSEG CODE:CODE:NOROOT(1)
//  390 void CleanupAndRunApplication (void)
CleanupAndRunApplication:
//  391 {
//  392   Disable_WatchDogTimer(); // After Reset the WDT state does not change
        REQUIRE ?Subroutine11
        ;               // Fall through to label ?Subroutine11

        RSEG CODE:CODE:NOROOT(1)
?Subroutine11:
        RCALL   Disable_WatchDogTimer
        LDI     R30, LOW(20)
        LDI     R31, (20) >> 8
        IJMP
//  393   void (*FuncPtr) (void) = (void (*)(void)) ((LAST_INTVECT_ADDRESS + 2) / 2);	// Set up function pointer to address after last interrupt vector. 
//  394   FuncPtr ();
//  395 }
//  396 
//  397 /***********************************************************************/
//  398 
//  399 /***********************************************************************/
//  400 

        RSEG CODE:CODE:NOROOT(1)
//  401 void ProcessPageErase (void)
ProcessPageErase:
//  402 {
        RCALL   ?PROLOGUE3_L09
//  403   uint16_t addr = 0;
//  404   uint8_t i;
//  405 
//  406   for (i = 0; i < PAGE_SIZE; ++i)
        LDI     R16, 0
//  407   {
//  408     pageBuffer[i] = 0xFF;
??ProcessPageErase_0:
        LDI     R18, 255
        LDI     R17, 0
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(pageBuffer) & 0xFFFF))
        SBCI    R31, (-(pageBuffer) & 0xFFFF) >> 8
        ST      Z, R18
//  409   }
        INC     R16
        CPI     R16, 64
        BRCS    ??ProcessPageErase_0
//  410 
//  411   UpdatePage (addr);		// To restore reset vector
        LDI     R16, 0
        RCALL   UpdatePage
//  412   addr += PAGE_SIZE;
        LDI     R24, 64
        LDI     R25, 0
//  413 
//  414   for (i = 0; i < (LAST_PAGE_NO_TO_BE_ERASED - 1); i++, addr += PAGE_SIZE)
        LDI     R26, 111
//  415   {
//  416     addr &= ~(PAGE_SIZE - 1);
??ProcessPageErase_1:
        ANDI    R24, 0xC0
//  417     
//  418     if (addr < BOOT_PAGE_ADDRESS)
        CPI     R25, 28
        BRCC    ??ProcessPageErase_2
//  419 	Erase_One_Page (addr); // Erase each page one by one until the bootloader section
        MOVW    R17:R16, R25:R24
        RCALL   Erase_One_Page
//  420   }
??ProcessPageErase_2:
        SUBI    R24, 192
        SBCI    R25, 255
        DEC     R26
        BRNE    ??ProcessPageErase_1
//  421 }
        RJMP    ?Subroutine10
//  422 
//  423 /***********************************************************************/
//  424 
//  425 /***********************************************************************/
//  426 

        RSEG CODE:CODE:NOROOT(1)
//  427 void Init_WatchDogTimer (void)
Init_WatchDogTimer:
//  428 {
//  429 /*
//  430 	Timed sequence to initialize watchdog timer
//  431 	for the given mode set in gtimeout variable
//  432 	Cross calls during maximum optimization can
//  433 	cause more than 4 cycles delay between change
//  434 	enable for WDT and setting values
//  435 */
//  436   asm ("push r0           \n" 
//  437        "push r24          \n" 
//  438        "lds r0, gtimeout  \n"   /* load the given settings    */
//  439        "ldi r24, 0x18     \n"	/* WDE, WCE                   */
//  440        "or r0, r24        \n"   /* set WDE and WCE            */
//  441        "wdr               \n"   /* reset the watchdog timer   */
//  442        "sts 0x0060, r24   \n"   /* change enable              */
//  443        "sts 0x0060, r0    \n"   /* make the change            */ 
//  444        "pop r24           \n" 
//  445        "pop r0            \n");
        push r0           
        push r24          
        lds r0, gtimeout  
        ldi r24, 0x18     
        or r0, r24        
        wdr               
        sts 0x0060, r24   
        sts 0x0060, r0    
        pop r24           
        pop r0            
//  446 }
        RET
//  447 /*
//  448 // LO = 4C, HI = DE
//  449 const uint16_t index_calc[16] = {
//  450   0, 52225, 55297, 5120, 61441, 15360, 10240, 58369,
//  451   40961, 27648, 30720 , 46081, 20480, 39937, 34817, 17408 };
//  452 #define MODULO_TWO_SUM( arg1, arg2, arg3)   ( arg1 ^ arg2 ^ arg3 )
//  453 void ProcessCRCCheck(void)
//  454 {
//  455   //
//  456   //CRC_LO <<= ((1 << 2) -1);
//  457   //CRC_HI += 0x5a;
//  458   //
//  459   uint16_t crc_sum=0;
//  460   uint16_t j=0;
//  461   unsigned char const __flash * i = ( unsigned char const __flash * ) 2; // Leave out the reset vector for CRC
//  462   uint8_t data;
//  463   while (i < (unsigned char const __flash *) BOOT_PAGE_ADDRESS )
//  464   {
//  465     data = __load_program_memory(i);
//  466     j=index_calc[crc_sum & 0xF];
//  467     crc_sum = (crc_sum >> 4) & 0x0FFF;
//  468     crc_sum = MODULO_TWO_SUM(crc_sum, j, index_calc[data & 0xF]);
//  469     
//  470     j= index_calc[crc_sum & 0xF];
//  471     crc_sum = (crc_sum >> 4) & 0x0FFF;
//  472     crc_sum = MODULO_TWO_SUM( crc_sum, j, index_calc[(data >> 4) & 0xF]);
//  473           
//  474     i++;
//  475   }
//  476   
//  477     CRC_HI = 0x00FF & (crc_sum >> 8);
//  478     CRC_LO = crc_sum & 0x00FF;  
//  479 }
//  480 */
//  481 
//  482 
//  483 /***********************************************************************/
//  484 
//  485 /***********************************************************************/
//  486 #ifdef __TWI__

        RSEG CODE:CODE:NOROOT(1)
//  487 void ProcessSlaveReceive (void)
ProcessSlaveReceive:
//  488 {
        SBIW    R29:R28, 1
//  489   uint8_t commandCode;
//  490  
//  491   if (SlaveReceiveByteAndACK (&commandCode) != 0)
        RCALL   ?Subroutine4
??CrossCallReturnLabel_19:
        BREQ    ??CrossCallReturnLabel_15
//  492   {
//  493     // Process command byte.
//  494     switch (commandCode)
        LD      R16, Y
        DEC     R16
        BREQ    ??ProcessSlaveReceive_0
        DEC     R16
        BREQ    ??ProcessSlaveReceive_1
        DEC     R16
        BREQ    ??ProcessSlaveReceive_2
        DEC     R16
        BREQ    ??ProcessSlaveReceive_3
        DEC     R16
        BREQ    ??ProcessSlaveReceive_4
        SUBI    R16, 2
        BREQ    ??ProcessSlaveReceive_5
        RJMP    ??ProcessSlaveReceive_6
//  495     {
//  496 	case TWI_CMD_PAGEUPDATE:
//  497 	  ProcessPageUpdate ();
??ProcessSlaveReceive_0:
        RCALL   ProcessPageUpdate
        RJMP    ??CrossCallReturnLabel_15
//  498 	break;
//  499 
//  500 	case TWI_CMD_EXECUTEAPP:
//  501 	  // Read dummy byte and NACK, just to be nice to our TWI master.
//  502 	  SlaveReceiveByteAndNACK (&commandCode);
??ProcessSlaveReceive_1:
        RCALL   ?Subroutine3
//  503           gtimeout = WDT_TIMEOUT_min; // Set WDT min for cleanup using reset
??CrossCallReturnLabel_8:
        LDI     R16, 0
        RCALL   ?Subroutine5
//  504           Init_WatchDogTimer();     // Apply the changes
//  505         while(1); // Wait for WDT reset
??CrossCallReturnLabel_10:
        RJMP    ??CrossCallReturnLabel_10
//  506           
//  507 	case TWI_CMD_AVERSION:
//  508 	  SlaveReceiveByteAndNACK (&commandCode);
??ProcessSlaveReceive_2:
        RCALL   ?Subroutine3
//  509 	  state = 2;
??CrossCallReturnLabel_7:
        LDI     R16, 2
??ProcessSlaveReceive_7:
        STS     state, R16
        RJMP    ??CrossCallReturnLabel_15
//  510 	break;
//  511 
//  512 	case TWI_CMD_BVERSION:
//  513 	  SlaveReceiveByteAndNACK (&commandCode);
??ProcessSlaveReceive_3:
        RCALL   ?Subroutine3
//  514 	  state = 1;
??CrossCallReturnLabel_6:
        LDI     R16, 1
        RJMP    ??ProcessSlaveReceive_7
//  515 	break;
//  516         /*
//  517         case TWI_CMD_CRCCHECK:
//  518           SlaveReceiveByteAndNACK (&commandCode);
//  519           ProcessCRCCheck();
//  520           state = 3;
//  521         break;
//  522 */
//  523 	case TWI_CMD_ERASEFLASH:
//  524 	  SlaveReceiveByteAndNACK (&commandCode);
??ProcessSlaveReceive_4:
        RCALL   ?Subroutine3
//  525 	  ProcessPageErase ();
??CrossCallReturnLabel_5:
        RCALL   ProcessPageErase
        RJMP    ??CrossCallReturnLabel_15
//  526 	break;
//  527         
//  528         case TWI_CMD_GETERRCONDN: // except TWI failure because that is the medium
//  529           SlaveReceiveByteAndNACK (&commandCode);
??ProcessSlaveReceive_5:
        RCALL   ?Subroutine3
//  530           state = 4;
??CrossCallReturnLabel_4:
        LDI     R16, 4
        RJMP    ??ProcessSlaveReceive_7
//  531         break;
//  532 
//  533 	default:
//  534 	  AbortTWI ();
??ProcessSlaveReceive_6:
        RCALL   ?Subroutine0
//  535     }
//  536   }
//  537 }
??CrossCallReturnLabel_15:
        REQUIRE ?Subroutine8
        REQUIRE _A_TWCR
        ;               // Fall through to label ?Subroutine8

        RSEG CODE:CODE:NOROOT(1)
?Subroutine8:
        ADIW    R29:R28, 1
        RET

        RSEG CODE:CODE:NOROOT(1)
?Subroutine4:
        MOVW    R17:R16, R29:R28
        REQUIRE ??Subroutine13_0
        ;               // Fall through to label ??Subroutine13_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine13_0:
        RCALL   SlaveReceiveByteAndACK
        TST     R16
        RET

        RSEG CODE:CODE:NOROOT(1)
?Subroutine3:
        MOVW    R17:R16, R29:R28
        RJMP    SlaveReceiveByteAndNACK
//  538 #endif
//  539 /***********************************************************************/
//  540 
//  541 /***********************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  542 void Read_EEPROM_byte (uint8_t addr, unsigned char *cValue)
Read_EEPROM_byte:
??Read_EEPROM_byte_0:
//  543 {
//  544 #ifdef __TWI__
//  545   while (EECR & (1 << EEPE));	// Wait until EEWE becomes zero
        SBIC    0x1F, 0x01
        RJMP    ??Read_EEPROM_byte_0
//  546   EEAR = addr;			// load eeprom adress
        OUT     0x21, R16
//  547   EECR = (1 << EERE);		// read enable
        LDI     R16, 1
        OUT     0x1F, R16
//  548   *cValue = EEDR;		// return eeprom data
        IN      R16, 0x20
        MOVW    R31:R30, R19:R18
        ST      Z, R16
//  549 #endif
//  550   
//  551 #ifdef __USI__
//  552   while (EECR & (1 << EEWE));	// Wait until EEWE becomes zero
//  553   EEAR = addr;			// load eeprom adress
//  554   EECR = (1 << EERE);		// read enable
//  555   *cValue = EEDR;		// return eeprom data
//  556 #endif
//  557 }
        RET
        REQUIRE _A_EEAR
        REQUIRE _A_EEDR
        REQUIRE _A_EECR
//  558 
//  559 /***********************************************************************/
//  560 
//  561 /***********************************************************************/
//  562 #ifdef __TWI__

        RSEG CODE:CODE:NOROOT(1)
//  563 void ReadAndProcessPacket (void)
ReadAndProcessPacket:
//  564 {
        SBIW    R29:R28, 1
//  565   unsigned char temp;
//  566   
//  567   // Enable ACK and clear pending interrupts.
//  568   TWCR = (1 << TWINT) | (1 << TWEA) | (1 << TWEN);
        LDI     R16, 196
        RCALL   ??Subroutine12_0
//  569   
//  570   // Wait for activity.
//  571   do{ } while ((TWCR & (1 << TWINT)) == 0);
??CrossCallReturnLabel_13:
        LDS     R16, _A_TWCR
        SBRS    R16, 7
        RJMP    ??CrossCallReturnLabel_13
//  572 
//  573   __watchdog_reset ();
        WDR
//  574 
//  575   // Check TWI status code for SLA+W or SLA+R.
//  576   switch (TWSR)
        LDS     R16, _A_TWSR
        SUBI    R16, 168
        BREQ    ??ReadAndProcessPacket_0
        SUBI    R16, 184
        BRNE    ??ReadAndProcessPacket_1
//  577   {
//  578     case TWI_SLAW_RECEIVED:
//  579       ProcessSlaveReceive ();
        RCALL   ProcessSlaveReceive
        RJMP    ??CrossCallReturnLabel_16
//  580     break;
//  581 
//  582     case TWI_SLAR_RECEIVED:
//  583       if (state == 0)
??ReadAndProcessPacket_0:
        LDS     R16, state
        TST     R16
        BRNE    ??ReadAndProcessPacket_2
//  584 	ProcessSlaveTransmit (GetStatusCode () & STATUSMASK_SPMBUSY);
        RCALL   GetStatusCode
        MOV     R17, R16
        ANDI    R17, 0x01
        MOV     R16, R17
??ReadAndProcessPacket_3:
        RCALL   ProcessSlaveTransmit
        RJMP    ??CrossCallReturnLabel_16
//  585       else if (state == 1)
??ReadAndProcessPacket_2:
        CPI     R16, 1
        BRNE    ??ReadAndProcessPacket_4
//  586       {
//  587 	state = 0;
        LDI     R16, 0
        STS     state, R16
//  588 	ProcessSlaveTransmit (BVERSION);
        LDI     R16, 150
        RJMP    ??ReadAndProcessPacket_3
//  589       }
//  590       else if (state == 2)
??ReadAndProcessPacket_4:
        CPI     R16, 2
        BRNE    ??CrossCallReturnLabel_16
//  591       {
//  592 	state = 0;
        LDI     R16, 0
        STS     state, R16
//  593 	Read_EEPROM_byte (EEMEM_ADDR_AVERSION, &temp);
        MOVW    R19:R18, R29:R28
        LDI     R16, 5
        RCALL   Read_EEPROM_byte
//  594 	ProcessSlaveTransmit (temp);
        LD      R16, Y
        RJMP    ??ReadAndProcessPacket_3
//  595       }
//  596      break;
//  597 
//  598     default:
//  599       AbortTWI ();
??ReadAndProcessPacket_1:
        RCALL   ?Subroutine0
//  600   }
//  601 }
??CrossCallReturnLabel_16:
        RJMP    ?Subroutine8
        REQUIRE _A_TWCR
        REQUIRE _A_TWSR
//  602 #endif
//  603 /***********************************************************************/
//  604 
//  605 /***********************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  606 void Start_Timer (void)
Start_Timer:
//  607 {
//  608     #ifdef __TWI__
//  609       TIFR1   = TIFR1;  // Clear flags
        IN      R16, 0x16
        OUT     0x16, R16
//  610       TCNT1H  = 0;
        LDI     R16, 0
        STS     133, R16
//  611       TCNT1L  = 0;
        STS     _A_TCNT1, R16
//  612       OCR1A   = 7813;   // 7812.5 (one sec at 8 MHz clock operation)
        LDI     R16, 133
        LDI     R17, 30
        STS     (_A_OCR1A + 1), R17
        STS     _A_OCR1A, R16
//  613       TCCR1B  = _BV (CS12) + _BV (CS10) + _BV (WGM12);	// mode4: CTC,
        LDI     R16, 13
        STS     _A_TCCR1B, R16
//  614                                                   // Prescaller:1024
//  615     #endif
//  616       
//  617      #ifdef __USI__
//  618       TIFR   = TIFR;  // Clear flags // 
//  619       // TCNT1H  = 0;
//  620       TCNT1  = 0;
//  621       //OCR1A   = 7813;   // 7812.5 (one sec at 8 MHz clock operation)//
//  622       OCR1A   = 255;   // 7812.5 (one sec at 8 MHz clock operation) // 
//  623       TCCR0A  = _BV (WGM01);	// mode4: CTC
//  624       TCCR0B  = _BV (CS02) + _BV (CS00);	// prescaller: 1024
//  625       
//  626     #endif
//  627 
//  628 }
        RET
        REQUIRE _A_TCNT1
        REQUIRE _A_TCCR1B
        REQUIRE _A_TIFR1
        REQUIRE _A_OCR1A
//  629 
//  630 // 10 s delay code for allowing ARM9 linux to boot  
//  631 #ifdef __TWI__
//  632 #define HOST_BOOT_DELAY_SEC 10
//  633 #endif
//  634 
//  635 #ifdef __USI__
//  636 #define HOST_BOOT_DELAY_SEC 500
//  637 #endif
//  638 
//  639 /***********************************************************************/
//  640 
//  641 /***********************************************************************/

        RSEG CODE:CODE:NOROOT(1)
//  642 void Host_Boot_Delay ()
Host_Boot_Delay:
//  643 {
        RCALL   ?PROLOGUE4_L09
//  644 //  time_lapse_sec = 0;
//  645 
//  646   Start_Timer ();
        RCALL   Start_Timer
//  647 #ifdef __TWI__
//  648   do{
//  649     if (TIFR1 & _BV (OCF1A))
??Host_Boot_Delay_0:
        SBIS    0x16, 0x01
        RJMP    ??Host_Boot_Delay_1
//  650     {
//  651       time_lapse_sec++;
        LDI     R30, LOW(time_lapse_sec)
        LDI     R31, (time_lapse_sec) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        SUBI    R16, 255
        SBCI    R17, 255
        ST      Z, R16
        STD     Z+1, R17
//  652       TIFR1 = TIFR1;
        IN      R16, 0x16
        OUT     0x16, R16
//  653     }
//  654   }
//  655   while (time_lapse_sec < HOST_BOOT_DELAY_SEC);
??Host_Boot_Delay_1:
        LDI     R26, LOW(time_lapse_sec)
        LDI     R27, (time_lapse_sec) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R31:R30, 10
        BRCS    ??Host_Boot_Delay_0
//  656   TCCR1B = 0;			
        LDI     R16, 0
        STS     _A_TCCR1B, R16
//  657   // stop the timer NOW
//  658 #endif
//  659   
//  660   // check this one later
//  661  #ifdef __USI__
//  662  do{
//  663     if (TIFR & _BV (OCF0A))
//  664     {
//  665       time_lapse_sec++;
//  666       TIFR = TIFR;
//  667         
//  668     }
//  669     
//  670   }
//  671   while (time_lapse_sec < HOST_BOOT_DELAY_SEC);
//  672   TCCR0B = 0;	
//  673   TCCR0A =0; 
//  674   // stop the timer NOW 
//  675 #endif  
//  676 }
        RJMP    ?Subroutine9
        REQUIRE _A_TCCR1B
        REQUIRE _A_TIFR1
//  677 
//  678 /***********************************************************************/
//  679 
//  680 /***********************************************************************/
//  681 // Main Starts from here

        RSEG CODE:CODE:NOROOT(1)
//  682 void main (void)
main:
//  683 {
//  684   
//  685      
//  686   if (MCUSR & _BV (PORF))	// Only in case of Power On Reset
        IN      R16, 0x34
        SBRS    R16, 0
        RJMP    ??main_0
//  687   {
//  688     MCUSR = 0;
        LDI     R16, 0
        OUT     0x34, R16
//  689 
//  690 
//  691 // Select the LED0 and LED1 interfacing port pins
//  692 #if defined(__ATTINY25__)   | defined(__ATTINY25V__) | \ 
//  693     defined(__ATTINY45__)   | defined(__ATTINY45V__) | \ 
//  694     defined(__ATTINY85__)   | defined(__ATTINY85V__) | \ 
//  695     defined(__ATTINY2313__) | defined(__ATTINY2313A__) | \ 
//  696     defined(__ATTINY4313__) | defined(__ATTINY4313A__) | \ 
//  697     defined(__ATTINY261__)  | defined(__ATTINY261A__) | \ 
//  698     defined(__ATTINY461__)  | defined(__ATTINY461A__) | \ 
//  699     defined(__ATTINY861__)  | defined(__ATTINY861A__) | \ 
//  700     defined(__ATTINY43U__)  | \ 
//  701     defined(__ATTINY87__)   | \ 
//  702     defined(__ATTINY167__) | \ 
//  703     defined(__ATTINY48__) | defined(__ATTINY88__) | \ 
//  704     defined(__ATMEGA48__) | \ 
//  705     defined(__ATMEGA48A__) | defined(__ATMEGA48PA__)
//  706       
//  707     DDRB |= (_BV (1) + _BV (3));	// otp LED iterface
        IN      R16, 0x04
        ORI     R16, 0x0A
        OUT     0x04, R16
//  708     PORTB &= ~(_BV (1) + _BV (3));     // ON the LEDs
        IN      R16, 0x05
        ANDI    R16, 0xF5
        OUT     0x05, R16
//  709     Host_Boot_Delay ();
        RCALL   Host_Boot_Delay
//  710     PORTB |= (_BV (1) + _BV (3));     // OFF the LEDs
        IN      R16, 0x05
        ORI     R16, 0x0A
        OUT     0x05, R16
//  711     
//  712     
//  713       
//  714 #endif
//  715     
//  716     
//  717 #if defined(__ATTINY24__)   | defined(__ATTINY24A__) | \ 
//  718     defined(__ATTINY44__)   | defined(__ATTINY44A__) | \ 
//  719     defined(__ATTINY84__)   | defined(__ATTINY84A__)
//  720       
//  721     DDRB |= (_BV (1) + _BV (2));	// otp LED iterface
//  722     PORTB &= ~(_BV (1) + _BV (2));     // ON the LEDs
//  723     Host_Boot_Delay ();
//  724     
//  725     
//  726     PORTB |= (_BV (1) + _BV (2));     // OFF the LEDs
//  727     
//  728     
//  729     
//  730 
//  731 #endif          
//  732   }
//  733   
//  734   if (IsBootPinLow ())
??main_0:
        RCALL   IsBootPinLow
        TST     R16
        BREQ    ??main_1
//  735   {     
//  736       #ifdef __TWI__
//  737           InitTWI();
        RCALL   InitTWI
//  738       #endif
//  739     
//  740           
//  741       #ifdef __USI__
//  742            USI_TWI_SLAVE_Init( SLAVE_ADDRESS );
//  743            //__enable_interrupt();
//  744       #endif
//  745 
//  746     
//  747     
//  748     gtimeout = WDT_TIMEOUT_8s;
        LDI     R16, 33
        RCALL   ?Subroutine5
//  749     Init_WatchDogTimer ();
//  750     
//  751     while (1)
//  752     {
//  753           #ifdef __TWI__
//  754               // Process the TWI Commands
//  755               ReadAndProcessPacket ();
??CrossCallReturnLabel_9:
        RCALL   ReadAndProcessPacket
        RJMP    ??CrossCallReturnLabel_9
//  756            #endif
//  757               
//  758            #ifdef __USI__
//  759               // Process the USI based TWI Commands
//  760               USI_TWI_SLAVE_ReadAndProcessPacket ();
//  761            #endif
//  762     }
//  763   }
//  764   else
//  765   {
//  766     CleanupAndRunApplication ();
??main_1:
        RJMP    ?Subroutine11
        REQUIRE _A_MCUSR
        REQUIRE _A_PORTB
        REQUIRE _A_DDRB
//  767   }
//  768 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine5:
        STS     (state + 1), R16
        RJMP    Init_WatchDogTimer

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        END
// 
//  20 bytes in segment ABSOLUTE
// 848 bytes in segment CODE
//   6 bytes in segment INITTAB
//  64 bytes in segment NEAR_N
//   5 bytes in segment NEAR_Z
// 
// 848 bytes of CODE memory (+  6 bytes shared)
//  69 bytes of DATA memory (+ 20 bytes shared)
//
//Errors: none
//Warnings: 1
